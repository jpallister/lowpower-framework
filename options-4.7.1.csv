#Flags,Grouping,Os,Values,Default,Conforming?,Description,Prerequisites,Implies
-fbranch-count-reg,O0,,,,,"When disabled, do not use “decrement and branch” instructions on a count register, but instead generate a sequence of instructions that decrement a register, compare it against zero then branch based upon the result.",,
-ffunction-cse,O0,,,,,When disabled do not put function addresses in registers; make each instruction that calls a constant function contain the function's address explicitly.,,
-fira-share-save-slots,O0,,,,,When disabled do not share stack slots used for saving call-used hard registers living through a call. Each hard register gets a separate stack slot and as a result function stack frames are longer,,
-fira-share-spill-slots,O0,,,,,When disabled do not share stack slows allocated for pseudo-register. Each pseudo-register that does not get a hard register gets a separate stack slot and as a result function stack frames are longer.,,
-fprefetch-loop-arrays,O0,NoOs,,,,"If supported by the target machine, generate instructions to prefetch memory to improve the performance of loops that access large arrays.",,
-ftree-vect-loop-version,O0,NoOs,,,,"Perform loop versioning when doing loop vectorization on trees. When a loop appears to be vectorizable except that data alignment or data dependence cannot be determined at compile time, then vectorized and non-vectorized versions of the loop are generated along with run-time checks for alignment or dependence to control which version is executed.",,
-funit-at-a-time,O0,,,,,This option is left for compatibility reasons. ,,
-fzero-initialized-in-bss,O0,,,,,When disabled variables are not put in BSS.,,
-fauto-inc-dec,O1,,,,,Combine increments or decrements of addresses with memory accesses. This pass is always skipped on architectures that do not have instructions to support this.,,
-fcombine-stack-adjustments,O1,,,,,Tracks stack adjustments (pushes and pops) and stack memory references and then tries to find ways to combine them.,,
-fcompare-elim,O1,,,,,"After register allocation and post-register allocation instruction splitting, identify arithmetic instructions that compute processor flags similar to a comparison operation based on that arithmetic. If possible, eliminate the explicit comparison operation.",,
-fcprop-registers,O1,,,,,"After register allocation and post-register allocation instruction splitting, we perform a copy-propagation pass to try to reduce scheduling dependencies and occasionally eliminate the copy.",,
-fdce,O1,,,,,Perform dead code elimination (DCE) on RTL.,,
-fdefer-pop,O1,,,,,,,
-fdelayed-branch,O1,,,,,"If supported for the target machine, attempt to reorder instructions to exploit instruction slots available after delayed branch instructions.",,
-fdse,O1,,,,,Perform dead store elimination (DSE) on RTL,,
-fguess-branch-probability,O1,,,,,"GCC will use heuristics to guess branch probabilities if they are not provided by profiling feedback (-fprofile-arcs). These heuristics are based on the control flow graph. If some branch probabilities are specified by `__builtin_expect', then the heuristics will be used to guess branch probabilities for the rest of the control flow graph, taking the `__builtin_expect' info into account. ",,
-fif-conversion,O1,,,,,"Attempt to transform conditional jumps into branch-less equivalents. This include use of conditional moves, min, max, set flags and abs instructions, and some tricks doable by standard arithmetics. The use of conditional execution on chips where it is available is controlled by if-conversion2.",,
-fif-conversion2,O1,,,,,Use conditional execution (where available) to transform conditional jumps into branch-less equivalents.,,
-finline-functions-called-once,O1,,,,,"Consider all static functions called once for inlining into their caller even if they are not marked inline. If a call to a given function is integrated, then the function is not output as assembler code in its own right.",,
-fipa-profile,O1,,,,,"Perform interprocedural profile propagation. The functions called only from cold functions are marked as cold. Also functions executed once (such as cold, noreturn, static constructors or destructors) are identified. Cold functions and loop less parts of functions executed once are then optimized for size.",,
-fipa-pure-const,O1,,,,,Discover which functions are pure or constant.,,
-fipa-reference,O1,,,,,Discover which static variables do not escape cannot escape the compilation unit.,,
-fmerge-constants,O1,,,,,Attempt to merge identical constants (string constants and floating-point constants) across compilation units.,,
-fmove-loop-invariants,O1,,,,,Enables the loop invariant motion pass in the RTL loop optimizer. ,,
-fomit-frame-pointer,O1,,,,,"Don't keep the frame pointer in a register for functions that don't need one. This avoids the instructions to save, set up and restore frame pointers; it also makes an extra register available in many functions. It also makes debugging impossible on some machines.",,
-fshrink-wrap,O1,,,,,"Emit function prologues only before parts of the function that need it, rather than at the top of the function",,
-fsplit-wide-types,O1,,,,,"When using a type that occupies multiple registers, such as long long on a 32-bit system, split the registers apart and allocate them independently. This normally generates better code for those types, but may make debugging more difficult.",,
-ftree-bit-ccp,O1,,,,,Perform sparse conditional bit constant propagation on trees and propagate pointer alignment information.,-ftree-ccp ,
-ftree-ccp,O1,,,,,Perform sparse conditional constant propagation (CCP) on trees,,
-ftree-ch,O1,NoOs,,,,Perform loop header copying on trees. This is beneficial since it increases effectiveness of code motion optimizations. It also saves one jump.,,
-ftree-copy-prop,O1,,,,,Perform copy propagation on trees. This pass eliminates unnecessary copy operations.,,
-ftree-copyrename,O1,,,,,"Perform copy renaming on trees. This pass attempts to rename compiler temporaries to other variables at copy locations, usually resulting in variable names which more closely resemble the original variables. This flag is enabled by default at -O and higher. ",,
-ftree-dce,O1,,,,,Perform dead code elimination (DCE) on trees,,
-ftree-dominator-opts,O1,,,,,"Perform a variety of simple scalar cleanups (constant/copy propagation, redundancy elimination, range propagation and expression simplification) based on a dominator tree traversal. This also performs jump threading (to reduce jumps to jumps).",,
-ftree-dse,O1,,,,,Perform dead store elimination (DSE) on trees. A dead store is a store into a memory location that is later overwritten by another store without any intervening loads. In this case the earlier store can be deleted.,,
-ftree-forwprop,O1,,,,,Perform forward propagation on trees. ,,
-ftree-fre,O1,,,,,"Perform full redundancy elimination (FRE) on trees. The difference between FRE and PRE is that FRE only considers expressions that are computed on all paths leading to the redundant computation. This analysis is faster than PRE, though it exposes fewer redundancies.",,
-ftree-loop-optimize,O1,,,,,Perform loop optimizations on trees.,,
-ftree-phiprop,O1,,,,,Perform hoisting of loads from conditional pointers on trees.,,
-ftree-pta,O1,,,,,,,
-ftree-reassoc,O1,,,,,Perform reassociation on trees.,,
-ftree-sink,O1,,,,,Perform forward store motion on trees. ,,
-ftree-sra,O1,,,,,Perform scalar replacement of aggregates. This pass replaces structure references with scalars to prevent committing structures to memory too early. This flag is enabled by default at -O and higher. ,,
-ftree-ter,O1,,,,,"Perform temporary expression replacement during the SSA->normal phase. Single use/single def temporaries are replaced at their use location with their defining expression. This results in non-GIMPLE code, but gives the expanders much more complex trees to work on resulting in better RTL generation. This is enabled by default at -O and higher. ",,
-falign-functions,O2,NoOs,,,,"Align the start of functions to the next power-of-two greater than n, skipping up to n bytes. ",,
-falign-jumps,O2,NoOs,,,,"Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping, skipping up to n bytes like -falign-functions. In this case, no dummy operations need be executed",,
-falign-labels,O2,NoOs,,,,"Align all branch targets to a power-of-two boundary, skipping up to n bytes like -falign-functions. ",,
-falign-loops,O2,NoOs,,,,"Align loops to a power-of-two boundary, skipping up to n bytes like -falign-functions. The hope is that the loop will be executed many times, which will make up for any execution of the dummy operations.",,
-fcaller-saves,O2,,,,,"Enable values to be allocated in registers that will be clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls. Such allocation is done only when it seems to result in better code than would otherwise be produced.",,
-fcrossjumping,O2,,,,,Perform cross-jumping transformation. This transformation unifies equivalent code and save code size. The resulting code may or may not perform better than without cross-jumping.,,
-fcse-follow-jumps,O2,,,,,"In common subexpression elimination (CSE), scan through jump instructions when the target of the jump is not reached by any other path. For example, when CSE encounters an if statement with an elseclause, CSE will follow the jump when the condition tested is false.",,
-fcse-skip-blocks,O2,,,,,"This is similar to -fcse-follow-jumps, but causes CSE to follow jumps that conditionally skip over blocks. When CSE encounters a simple if statement with no else clause, -fcse-skip-blocks causes CSE to follow the jump around the body of the if.",,
-fdelete-null-pointer-checks,O2,,,,,,,
-fdevirtualize,O2,,,,,Attempt to convert calls to virtual functions to direct calls. This is done both within a procedure and interprocedurally as part of indirect inlining (-findirect-inlining) and interprocedural constant propagation (-fipa-cp). ,,
-fexpensive-optimizations,O2,,,,,Perform a number of minor optimizations that are relatively expensive.,,
-fgcse,O2,,,,,Perform a global common subexpression elimination pass. This pass also performs global constant and copy propagation.,,-fgcse-lm
-fgcse-lm,O2,,,,,"When -fgcse-lm is enabled, global common subexpression elimination will attempt to move loads that are only killed by stores into themselves. This allows a loop containing a load/store sequence to be changed to a load outside the loop, and a copy/store within the loop.",-fgcse,
-findirect-inlining,O2,,,,,Inline also indirect calls that are discovered to be known at compile time thanks to previous inlining. This option has any effect only when inlining itself is turned on by the -finline-functions or -finline-small-functions options.,-finline-functions or -finline-small-functions,
-finline-small-functions,O2,,,,,"Integrate functions into their callers when their body is smaller than expected function call code (so overall size of program gets smaller). The compiler heuristically decides which functions are simple enough to be worth integrating in this way. This inlining applies to all functions, even those not declared inline.",,
-fipa-cp,O2,,,,,Perform interprocedural constant propagation. This optimization analyzes the program to determine when values passed to functions are constants and then optimizes accordingly. This optimization can substantially increase performance if the application has constants passed to functions.,,
-fipa-sra,O2,,,,,"Perform interprocedural scalar replacement of aggregates, removal of unused parameters and replacement of parameters passed by reference by parameters passed by value.",,
-foptimize-sibling-calls,O2,,,,,Optimize sibling and tail recursive calls.,,
-fpartial-inlining,O2,,,,,Inline parts of functions. This option has any effect only when inlining itself is turned on by the -finline-functions or -finline-small-functions options.,-finline-functions or -finline-small-functions,
-fpeephole2,O2,,,,,Machine-specific peephole optimizations.,,
-fregmove,O2,,,,,Attempt to reassign register numbers in move instructions and as operands of other simple instructions in order to maximize the amount of register tying. This is especially helpful on machines with two-operand instructions.,,
-freorder-blocks,O2,NoOs,,,,Reorder basic blocks in the compiled function in order to reduce number of taken branches and improve code locality.,,
-freorder-functions,O2,,,,,Reorder functions in the object file in order to improve code locality. This is implemented by using special subsections .text.hot for most frequently executed functions and .text.unlikely for unlikely executed functions. Reordering is done by the linker so object file format must support named sections and linker must place them in a reasonable way.,profile information,
-frerun-cse-after-loop,O2,,,,,Re-run common subexpression elimination after loop optimizations has been performed.,,
-fsched-interblock,O2,,,,,Schedule instructions across basic blocks,-fschedule-insns,
-fsched-spec,O2,,,,,Allow speculative motion of non-load instructions,-fschedule-insns,
-fschedule-insns,O2,,,,,"If supported for the target machine, attempt to reorder instructions to eliminate execution stalls due to required data being unavailable. This helps machines that have slow floating point or memory load instructions by allowing other instructions to be issued until the result of the load or floating-point instruction is required.",,"-fsched-interblock, -fsched-spec, -fsched-group-heuristic, -fsched-critical-path-heuristic, -fsched-spec-insn-heuristic, -fsched-rank-heuristic, -fsched-last-insn-heuristic, -fsched-dep-count-heuristic"
-fschedule-insns2 ,O2,,,,,"Similar to -fschedule-insns, but requests an additional pass of instruction scheduling after register allocation has been done. This is especially useful on machines with a relatively small number of registers and where memory load instructions take more than one cycle.",,"-fsched-group-heuristic, -fsched-critical-path-heuristic, -fsched-spec-insn-heuristic, -fsched-rank-heuristic, -fsched-last-insn-heuristic, -fsched-dep-count-heuristic"
-fstrict-aliasing,O2,,,,,"Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled. For C (and C++), this activates optimizations based on the type of expressions. In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same.",,
-fstrict-overflow,O2,,,,,"Allow the compiler to assume strict signed overflow rules, depending on the language being compiled. For C (and C++) this means that overflow when doing arithmetic with signed numbers is undefined, which means that the compiler may assume that it will not happen. This permits various optimizations. For example, the compiler will assume that an expression like i + 10 > i will always be true for signed i. ",,
-fthread-jumps,O2,,,,,"Perform optimizations where we check to see if a jump branches to a location where another comparison subsumed by the first is found. If so, the first branch is redirected to either the destination of the second branch or a point immediately following it, depending on whether the condition is known to be true or false.",,
-ftree-builtin-call-dce,O2,NoOs,,,,Perform conditional dead code elimination (DCE) for calls to builtin functions that may set errno but are otherwise side-effect free. ,,
-ftree-pre,O2,,,,,Perform partial redundancy elimination (PRE) on trees.,,
-ftree-switch-conversion,O2,,,,,Perform conversion of simple initializations in a switch to initializations from a scalar array.,,
-ftree-tail-merge,O2,,,,,"Look for identical code sequences. When found, replace one with a jump to the other. This optimization is known as tail merging or cross jumping. ",,
-ftree-vrp,O2,,,,,"Perform Value Range Propagation on trees. This is similar to the constant propagation pass, but instead of values, ranges of values are propagated. This allows the optimizers to remove unnecessary range checks like array bound checks and null pointer checks. ",,
-fgcse-after-reload,O3,,,,,"When -fgcse-after-reload is enabled, a redundant load elimination pass is performed after reload. The purpose of this pass is to cleanup redundant spilling. ",,
-finline-functions,O3,,,,,"Consider all functions for inlining, even if they are not declared inline. The compiler heuristically decides which functions are worth integrating in this way.",,
-fipa-cp-clone,O3,,,,,"Perform function cloning to make interprocedural constant propagation stronger. When enabled, interprocedural constant propagation will perform function cloning when externally visible function can be called with constant arguments. Because this optimization can create multiple copies of functions, it may significantly increase code size (see --param ipcp-unit-growth=value)",,
-fpredictive-commoning,O3,,,,,"Perform predictive commoning optimization, i.e., reusing computations (especially memory loads and stores) performed in previous iterations of loops.",,
-ftree-loop-distribute-patterns,O3,,,,,Perform loop distribution of patterns that can be code generated with calls to a library.,,
-ftree-slp-vectorize,O3,,,,,Perform basic block vectorization on trees.,-ftree-vectorize,
-ftree-vectorize,O3,,,,,Perform loop vectorization on trees,,
-funswitch-loops,O3,,,,,"Move branches with loop invariant conditions out of the loop, with duplicates of the loop on both branches (modified according to result of the condition).",,
-fira-loop-pressure,O3,,,,,"Use IRA to evaluate register pressure in loops for decisions to move loop invariants. This option usually results in generation of faster and smaller code on machines with large register files (>= 32 registers), but it can slow the compiler down.",,
-fassociative-math,,,,,N,Allow re-association of operands in series of floating-point operations. This violates the ISO C and C++ language standard by possibly changing computation result.,,
-fbranch-target-load-optimize,,,,,,"Perform branch target register load optimization before prologue / epilogue threading. The use of target registers can typically be exposed only during reload, thus hoisting loads out of loops and doing inter-block scheduling needs a separate optimization pass. ",,
-fbranch-target-load-optimize2,,,,,,Perform branch target register load optimization after prologue / epilogue threading. ,,
-fbtr-bb-exclusive,,,,,,"When performing branch target register load optimization, don't reuse branch target registers in within any basic block. ",-fbranch-target-load-optimize or -fbranch-target-load-optimize2,
-fconserve-stack,,,,,,"Attempt to minimize stack usage. The compiler will attempt to use less stack space, even if that makes the program slower.",,"--param large-stack-frame=100, --param large-stack-frame-growth=400"
-ffast-math,,,,,N,Sets some flags,," -fno-math-errno, -funsafe-math-optimizations, -ffinite-math-only, -fno-rounding-math, -fno-signaling-nans, -fcx-limited-range"
-fforward-propagate,,,,,,"Perform a forward propagation pass on RTL. The pass tries to combine two instructions and checks if the result can be simplified. If loop unrolling is active, two passes are performed and the second is scheduled after loop unrolling",,
-ffp-contract,,,"fast, off",fast,,-ffp-contract=off disables floating-point expression contraction. -ffp-contract=fast enables floating-point expression contraction such as forming of fused multiply-add operations if the target has native support for them. -ffp-contract=on enables floating-point expression contraction if allowed by the language standard. This is currently not implemented and treated equal to -ffp-contract=off.,,
-fgcse-las,,,,,,"When -fgcse-las is enabled, the global common subexpression elimination pass eliminates redundant loads that come after stores to the same memory location (both partial and full redundancies).",-fgcse,
-fgcse-sm,,,,,,"When -fgcse-sm is enabled, a store motion pass is run after global common subexpression elimination. This pass will attempt to move stores out of loops. When used in conjunction with -fgcse-lm, loops containing a load/store sequence can be changed to a load before the loop and a store after the loop.",-fgcse,
-finline-limit,,,1+,?,,"By default, GCC limits the size of functions that can be inlined. This flag allows coarse control of this limit. n is the size of functions that can be inlined in number of pseudo instructions.",,"--param max-inline-insns-single=N/2, --param max-inline-insns-auto=n/2"
-fipa-matrix-reorg,,,,,,"Perform matrix flattening and transposing. Matrix flattening tries to replace an m-dimensional matrix with its equivalent n-dimensional matrix, where n < m. This reduces the level of indirection needed for accessing the elements of the matrix. The second optimization is matrix transposing, which attempts to change the order of the matrix's dimensions in order to improve cache locality",profile information,
-fipa-pta,,,,,,Perform interprocedural pointer analysis and interprocedural modification and reference analysis. This option can cause excessive memory and compile-time usage on large compilation units.,,
-fira-algorithm,,,"priority, CB",?,,"Use the specified coloring algorithm for the integrated register allocator. The algorithm argument can be `priority', which specifies Chow's priority coloring, or `CB', which specifies Chaitin-Briggs coloring. Chaitin-Briggs coloring is not implemented for all architectures, but for those targets that do support it, it is the default because it generates better code. ",,
-fira-region,,,"all, mixed, one","one for O0 and Os, mixed otherwise",,"Use specified regions for the integrated register allocator. The region argument should be one of the following:
l'
 all loops as register allocation regions. This can give the best results for machines with a small and/or irregular register set.
xed'
 all loops except for loops with small register pressure as the regions. This value usually gives the best results in most cases and for most architectures, and is enabled by default when compiling with optimization for speed (-O, -O2, ...).
e'
 all functions as a single region. This typically results in the smallest code size, and is enabled by default for -Os or -O0.

-fivopts,,,,,,"Perform induction variable optimizations (strength reduction, induction variable merging and induction variable elimination) on trees. ",,
-floop-block,,,,,,Perform loop blocking transformations on loops. Blocking strip mines each loop in the loop nest such that the memory accesses of the element loops fit inside caches. The strip length can be changed using the loop-block-tile-size parameter.,GRAPHITE,
-floop-flatten,,,,,,Removes the loop nesting structure: transforms the loop nest into a single loop. This transformation can be useful as an enablement transform for vectorization and parallelization. This feature is experimental,GRAPHITE,
-floop-interchange,,,,,,Perform loop interchange transformations on loops. Interchanging two nested loops switches the inner and outer loops. ,GRAPHITE,
-floop-parallelize-all,,,,,,Use the Graphite data dependence analysis to identify loops that can be parallelized. Parallelize all the loops that can be analyzed to not contain loop carried dependences without checking that it is profitable to parallelize the loops. ,GRAPHITE,
-floop-strip-mine,,,,,,Perform loop strip mining transformations on loops. Strip mining splits a loop into two nested loops. The outer loop has strides equal to the strip size and the inner loop has strides of the original loop within a strip. The strip length can be changed using the loop-block-tile-size parameter.,GRAPHITE,
-flto,,,,,,This option runs the standard link-time optimizer.,,
-flto-partition,,,"1to1, balanced, none",balanced,,Specify the partitioning algorithm used by the link-time optimizer. The value is either 1to1 to specify a partitioning mirroring the original source files or balanced to specify partitioning into equally sized chunks (whenever possible). Specifying none as an algorithm disables partitioning and streaming completely.,,
-fmerge-all-constants,,,,,N,Attempt to merge identical constants and identical variables.,,-fmerge-constants
-fmodulo-sched-allow-regmoves,,,,,,Perform more aggressive SMS based modulo scheduling with register moves allowed. By setting this flag certain anti-dependences edges will be deleted which will trigger the generation of reg-moves based on the life-range analysis. This option is effective only with -fmodulo-sched enabled. ,-fmodulo-sched,
-fmodulo-sched,,,,,,Perform swing modulo scheduling immediately before the first scheduling pass. This pass looks at innermost loops and reorders their instructions by overlapping different iterations. ,,
-fpeel-loops,,,,,,Peels loops for which there is enough information that they do not roll much (from profile feedback).,,-frename-registers
-frename-registers,,,,,,"Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation. This optimization will most benefit processors with lots of registers. Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables will no longer stay in a “home register”.",,
-freorder-blocks-and-partition,,NoOs,,,,"In addition to reordering basic blocks in the compiled function, in order to reduce number of taken branches, partitions hot and cold basic blocks into separate sections of the assembly and .o files, to improve paging and cache locality performance.",,
-freschedule-modulo-scheduled-loops,,,,,,"The modulo scheduling comes before the traditional scheduling, if a loop was modulo scheduled we may want to prevent the later scheduling passes from changing its schedule, we use this option to control that. ",-fschedule-insns or -fschedule-insns2,
-fsched-critical-path-heuristic,,,,,,Enable the critical-path heuristic in the scheduler. This heuristic favors instructions on the critical path.,-fschedule-insns or -fschedule-insns2,
-fsched-dep-count-heuristic,,,,,,Enable the dependent-count heuristic in the scheduler. This heuristic favors the instruction that has more instructions depending on it. ,-fschedule-insns or -fschedule-insns2,
-fsched-group-heuristic,,,,,,Enable the group heuristic in the scheduler. This heuristic favors the instruction that belongs to a schedule group,-fschedule-insns or -fschedule-insns2,
-fsched-last-insn-heuristic,,,,,,Enable the last-instruction heuristic in the scheduler. This heuristic favors the instruction that is less dependent on the last instruction scheduled.,-fschedule-insns or -fschedule-insns2,
-fsched-pressure,,,,,,"Enable register pressure sensitive insn scheduling before the register allocation. This only makes sense when scheduling before register allocation is enabled, i.e. with -fschedule-insns or at -O2 or higher. Usage of this option can improve the generated code and decrease its size by preventing register pressure increase above the number of available hard registers and as a consequence register spills in the register allocation. ",-fschedule-insns,
-fsched-rank-heuristic,,,,,,Enable the rank heuristic in the scheduler. This heuristic favors the instruction belonging to a basic block with greater size or frequency.,-fschedule-insns or -fschedule-insns2,
-fsched-spec-insn-heuristic,,,,,,Enable the speculative instruction heuristic in the scheduler. This heuristic favors speculative instructions with greater dependency weakness. ,-fschedule-insns or -fschedule-insns2,
-fsched-spec-load,,,,,,Allow speculative motion of some load instructions.,-fschedule-insns,
-fsched-spec-load-dangerous,,,,,,Allow speculative motion of some load instructions.,-fschedule-insns,
-fsched-stalled-insns,,,0+,?,,"Define how many insns (if any) can be moved prematurely from the queue of stalled insns into the ready list, during the second scheduling pass. ",-fschedule-insns,
-fsched-stalled-insns-dep,,,0+,?,,Define how many insn groups (cycles) will be examined for a dependency on a stalled insn that is candidate for premature removal from the queue of stalled insns.,-fschedule-insns,
-fsched2-use-superblocks,,,,,,"When scheduling after register allocation, do use superblock scheduling algorithm. Superblock scheduling allows motion across basic block boundaries resulting on faster schedules. This option is experimental, as not all machine descriptions used by GCC model the CPU closely enough to avoid unreliable results from the algorithm.",-fschedule-insns2,
-fsel-sched-pipelining,,,,,,Enable software pipelining of innermost loops during selective scheduling.,-fselective-scheduling or -fselective-scheduling2,
-fsel-sched-pipelining-outer-loops,,,,,,"When pipelining loops during selective scheduling, also pipeline outer loops. ",-fsel-sched-pipelining,
-fselective-scheduling,,,,,,Schedule instructions using selective scheduling algorithm. Selective scheduling runs instead of the first scheduler pass. ,-fschedule-insns or -fschedule-insns2,
-fselective-scheduling2,,,,,,Schedule instructions using selective scheduling algorithm. Selective scheduling runs instead of the second scheduler pass. ,-fschedule-insns or -fschedule-insns2,
-fsplit-ivs-in-unroller,,,,,,"Enables expressing of values of induction variables in later iterations of the unrolled loop using the value in the first iteration. This breaks long dependency chains, thus improving efficiency of the scheduling passes.",,
-ftracer,,,,,,Perform tail duplication to enlarge superblock size. This transformation simplifies the control flow of the function allowing other optimizations to do better job. ,,
-ftree-loop-distribution,,,,,,"Perform loop distribution. This flag can improve cache performance on big loop bodies and allow further loop optimizations, like parallelization or vectorization, to take place.",,
-ftree-loop-if-convert,,,,,,Attempt to transform conditional jumps in the innermost loops to branch-less equivalents. The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops. This is enabled by default if vectorization is enabled. ,,
-ftree-loop-if-convert-stores,,,,,N,Attempt to also if-convert conditional jumps containing memory writes. This transformation can be unsafe for multi-threaded programs as it transforms conditional memory writes into unconditional memory writes,,
-ftree-loop-im,,,,,,"Perform loop invariant motion on trees. This pass moves only invariants that would be hard to handle at RTL level (function calls, operations that expand to nontrivial sequences of insns). With -funswitch-loops it also moves operands of conditions that are invariant out of the loop, so that we can use just trivial invariantness analysis in loop unswitching. The pass also includes store motion. ",,
-ftree-loop-ivcanon,,,,,,Create a canonical counter for number of iterations in loops for which determining number of iterations requires complicated analysis. Later optimizations then may determine the number easily. Useful especially in connection with unrolling. ,,
-ftree-parallelize-loops=n,,,1+,,,"Parallelize loops, i.e., split their iteration space to run in n threads. This is only possible for loops whose iterations are independent and can be arbitrarily reordered. The optimization is only profitable on multiprocessor machines, for loops that are CPU-intensive, rather than constrained e.g. by memory bandwidth. This option implies -pthread, and thus is only supported on targets that have support for -pthread. ",pthreads,
-funroll-all-loops,,,,,,"Unroll all loops, even if their number of iterations is uncertain when the loop is entered. This usually makes programs run more slowly. -funroll-all-loops implies the same options as -funroll-loops, ",,"-frerun-cse-after-loop, -fweb, -frename-registers"
-funroll-loops,,,,,,"Unroll loops whose number of iterations can be determined at compile time or upon entry to the loop. -funroll-loops implies -frerun-cse-after-loop. This option makes code larger, and may or may not make it run faster. ",,"-frerun-cse-after-loop, -fweb, -frename-registers"
-funsafe-loop-optimizations,,,,,,"If given, the loop optimizer will assume that loop indices do not overflow, and that the loops with nontrivial exit condition are not infinite. This enables a wider range of loop optimizations even if the loop optimizer itself cannot prove that these assumptions are valid. ",,
-fvariable-expansion-in-unroller,,,,,,"With this option, the compiler will create multiple copies of some local variables when unrolling a loop which can result in superior code. ",,
-fvect-cost-model,,,,,,Enable cost model for vectorization. ,,
-fweb,,,,,,"Constructs webs as commonly used for register allocation purposes and assign each web individual pseudo register. This allows the register allocation pass to operate on pseudos directly, but also strengthens several other optimization passes, such as CSE, loop optimizer and trivial dead code remover. It can, however, make debugging impossible, since variables will no longer stay in a “home register”.",,
-fwhole-program,,,,,,Assume that the current compilation unit represents the whole program being compiled. All public functions and variables with the exception of main and those merged by attribute externally_visiblebecome static functions and in effect are optimized more aggressively by interprocedural optimizers.,,
